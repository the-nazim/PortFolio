{"ast":null,"code":"\"use client\";\n\n// src/toast.tsx\nimport _objectSpread from \"/home/nazim/Documents/Portfolio/PortFolio/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/nazim/Documents/Portfolio/PortFolio/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"__scopeToast\", \"hotkey\", \"label\"],\n  _excluded2 = [\"__scopeToast\", \"onFocusFromOutsideViewport\"],\n  _excluded3 = [\"forceMount\", \"open\", \"defaultOpen\", \"onOpenChange\"],\n  _excluded4 = [\"__scopeToast\", \"type\", \"duration\", \"open\", \"onClose\", \"onEscapeKeyDown\", \"onPause\", \"onResume\", \"onSwipeStart\", \"onSwipeMove\", \"onSwipeCancel\", \"onSwipeEnd\"],\n  _excluded5 = [\"__scopeToast\", \"children\"],\n  _excluded6 = [\"__scopeToast\"],\n  _excluded7 = [\"__scopeToast\"],\n  _excluded8 = [\"altText\"],\n  _excluded9 = [\"__scopeToast\"],\n  _excluded0 = [\"__scopeToast\", \"altText\"];\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport * as DismissableLayer from \"@radix-ui/react-dismissable-layer\";\nimport { Portal } from \"@radix-ui/react-portal\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive, dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { VisuallyHidden } from \"@radix-ui/react-visually-hidden\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar PROVIDER_NAME = \"ToastProvider\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(\"Toast\");\nvar [createToastContext, createToastScope] = createContextScope(\"Toast\", [createCollectionScope]);\nvar [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);\nvar ToastProvider = props => {\n  const {\n    __scopeToast,\n    label = \"Notification\",\n    duration = 5e3,\n    swipeDirection = \"right\",\n    swipeThreshold = 50,\n    children\n  } = props;\n  const [viewport, setViewport] = React.useState(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n  if (!label.trim()) {\n    console.error(\"Invalid prop `label` supplied to `\".concat(PROVIDER_NAME, \"`. Expected non-empty `string`.\"));\n  }\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: __scopeToast,\n    children: /* @__PURE__ */jsx(ToastProviderProvider, {\n      scope: __scopeToast,\n      label,\n      duration,\n      swipeDirection,\n      swipeThreshold,\n      toastCount,\n      viewport,\n      onViewportChange: setViewport,\n      onToastAdd: React.useCallback(() => setToastCount(prevCount => prevCount + 1), []),\n      onToastRemove: React.useCallback(() => setToastCount(prevCount => prevCount - 1), []),\n      isFocusedToastEscapeKeyDownRef,\n      isClosePausedRef,\n      children\n    })\n  });\n};\nToastProvider.displayName = PROVIDER_NAME;\nvar VIEWPORT_NAME = \"ToastViewport\";\nvar VIEWPORT_DEFAULT_HOTKEY = [\"F8\"];\nvar VIEWPORT_PAUSE = \"toast.viewportPause\";\nvar VIEWPORT_RESUME = \"toast.viewportResume\";\nvar ToastViewport = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = \"Notifications ({hotkey})\"\n    } = props,\n    viewportProps = _objectWithoutProperties(props, _excluded);\n  const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n  const getItems = useCollection(__scopeToast);\n  const wrapperRef = React.useRef(null);\n  const headFocusProxyRef = React.useRef(null);\n  const tailFocusProxyRef = React.useRef(null);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n  const hotkeyLabel = hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n  const hasToasts = context.toastCount > 0;\n  React.useEffect(() => {\n    const handleKeyDown = event => {\n      var _ref$current;\n      const isHotkeyPressed = hotkey.length !== 0 && hotkey.every(key => event[key] || event.code === key);\n      if (isHotkeyPressed) (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();\n    };\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [hotkey]);\n  React.useEffect(() => {\n    const wrapper = wrapperRef.current;\n    const viewport = ref.current;\n    if (hasToasts && wrapper && viewport) {\n      const handlePause = () => {\n        if (!context.isClosePausedRef.current) {\n          const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n          viewport.dispatchEvent(pauseEvent);\n          context.isClosePausedRef.current = true;\n        }\n      };\n      const handleResume = () => {\n        if (context.isClosePausedRef.current) {\n          const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n          viewport.dispatchEvent(resumeEvent);\n          context.isClosePausedRef.current = false;\n        }\n      };\n      const handleFocusOutResume = event => {\n        const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);\n        if (isFocusMovingOutside) handleResume();\n      };\n      const handlePointerLeaveResume = () => {\n        const isFocusInside = wrapper.contains(document.activeElement);\n        if (!isFocusInside) handleResume();\n      };\n      wrapper.addEventListener(\"focusin\", handlePause);\n      wrapper.addEventListener(\"focusout\", handleFocusOutResume);\n      wrapper.addEventListener(\"pointermove\", handlePause);\n      wrapper.addEventListener(\"pointerleave\", handlePointerLeaveResume);\n      window.addEventListener(\"blur\", handlePause);\n      window.addEventListener(\"focus\", handleResume);\n      return () => {\n        wrapper.removeEventListener(\"focusin\", handlePause);\n        wrapper.removeEventListener(\"focusout\", handleFocusOutResume);\n        wrapper.removeEventListener(\"pointermove\", handlePause);\n        wrapper.removeEventListener(\"pointerleave\", handlePointerLeaveResume);\n        window.removeEventListener(\"blur\", handlePause);\n        window.removeEventListener(\"focus\", handleResume);\n      };\n    }\n  }, [hasToasts, context.isClosePausedRef]);\n  const getSortedTabbableCandidates = React.useCallback(_ref => {\n    let {\n      tabbingDirection\n    } = _ref;\n    const toastItems = getItems();\n    const tabbableCandidates = toastItems.map(toastItem => {\n      const toastNode = toastItem.ref.current;\n      const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n      return tabbingDirection === \"forwards\" ? toastTabbableCandidates : toastTabbableCandidates.reverse();\n    });\n    return (tabbingDirection === \"forwards\" ? tabbableCandidates.reverse() : tabbableCandidates).flat();\n  }, [getItems]);\n  React.useEffect(() => {\n    const viewport = ref.current;\n    if (viewport) {\n      const handleKeyDown = event => {\n        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n        const isTabKey = event.key === \"Tab\" && !isMetaKey;\n        if (isTabKey) {\n          const focusedElement = document.activeElement;\n          const isTabbingBackwards = event.shiftKey;\n          const targetIsViewport = event.target === viewport;\n          if (targetIsViewport && isTabbingBackwards) {\n            var _headFocusProxyRef$cu;\n            (_headFocusProxyRef$cu = headFocusProxyRef.current) === null || _headFocusProxyRef$cu === void 0 || _headFocusProxyRef$cu.focus();\n            return;\n          }\n          const tabbingDirection = isTabbingBackwards ? \"backwards\" : \"forwards\";\n          const sortedCandidates = getSortedTabbableCandidates({\n            tabbingDirection\n          });\n          const index = sortedCandidates.findIndex(candidate => candidate === focusedElement);\n          if (focusFirst(sortedCandidates.slice(index + 1))) {\n            event.preventDefault();\n          } else {\n            var _headFocusProxyRef$cu2, _tailFocusProxyRef$cu;\n            isTabbingBackwards ? (_headFocusProxyRef$cu2 = headFocusProxyRef.current) === null || _headFocusProxyRef$cu2 === void 0 ? void 0 : _headFocusProxyRef$cu2.focus() : (_tailFocusProxyRef$cu = tailFocusProxyRef.current) === null || _tailFocusProxyRef$cu === void 0 ? void 0 : _tailFocusProxyRef$cu.focus();\n          }\n        }\n      };\n      viewport.addEventListener(\"keydown\", handleKeyDown);\n      return () => viewport.removeEventListener(\"keydown\", handleKeyDown);\n    }\n  }, [getItems, getSortedTabbableCandidates]);\n  return /* @__PURE__ */jsxs(DismissableLayer.Branch, {\n    ref: wrapperRef,\n    role: \"region\",\n    \"aria-label\": label.replace(\"{hotkey}\", hotkeyLabel),\n    tabIndex: -1,\n    style: {\n      pointerEvents: hasToasts ? void 0 : \"none\"\n    },\n    children: [hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: headFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"forwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    }), /* @__PURE__ */jsx(Collection.Slot, {\n      scope: __scopeToast,\n      children: /* @__PURE__ */jsx(Primitive.ol, _objectSpread(_objectSpread({\n        tabIndex: -1\n      }, viewportProps), {}, {\n        ref: composedRefs\n      }))\n    }), hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: tailFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"backwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    })]\n  });\n});\nToastViewport.displayName = VIEWPORT_NAME;\nvar FOCUS_PROXY_NAME = \"ToastFocusProxy\";\nvar FocusProxy = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeToast,\n      onFocusFromOutsideViewport\n    } = props,\n    proxyProps = _objectWithoutProperties(props, _excluded2);\n  const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(VisuallyHidden, _objectSpread(_objectSpread({\n    tabIndex: 0\n  }, proxyProps), {}, {\n    ref: forwardedRef,\n    style: {\n      position: \"fixed\"\n    },\n    onFocus: event => {\n      var _context$viewport;\n      const prevFocusedElement = event.relatedTarget;\n      const isFocusFromOutsideViewport = !((_context$viewport = context.viewport) !== null && _context$viewport !== void 0 && _context$viewport.contains(prevFocusedElement));\n      if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n    }\n  }));\n});\nFocusProxy.displayName = FOCUS_PROXY_NAME;\nvar TOAST_NAME = \"Toast\";\nvar TOAST_SWIPE_START = \"toast.swipeStart\";\nvar TOAST_SWIPE_MOVE = \"toast.swipeMove\";\nvar TOAST_SWIPE_CANCEL = \"toast.swipeCancel\";\nvar TOAST_SWIPE_END = \"toast.swipeEnd\";\nvar Toast = React.forwardRef((props, forwardedRef) => {\n  const {\n      forceMount,\n      open: openProp,\n      defaultOpen,\n      onOpenChange\n    } = props,\n    toastProps = _objectWithoutProperties(props, _excluded3);\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen !== null && defaultOpen !== void 0 ? defaultOpen : true,\n    onChange: onOpenChange,\n    caller: TOAST_NAME\n  });\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || open,\n    children: /* @__PURE__ */jsx(ToastImpl, _objectSpread(_objectSpread({\n      open\n    }, toastProps), {}, {\n      ref: forwardedRef,\n      onClose: () => setOpen(false),\n      onPause: useCallbackRef(props.onPause),\n      onResume: useCallbackRef(props.onResume),\n      onSwipeStart: composeEventHandlers(props.onSwipeStart, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"start\");\n      }),\n      onSwipeMove: composeEventHandlers(props.onSwipeMove, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"move\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-x\", \"\".concat(x, \"px\"));\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-y\", \"\".concat(y, \"px\"));\n      }),\n      onSwipeCancel: composeEventHandlers(props.onSwipeCancel, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"cancel\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-y\");\n      }),\n      onSwipeEnd: composeEventHandlers(props.onSwipeEnd, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"end\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-x\", \"\".concat(x, \"px\"));\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-y\", \"\".concat(y, \"px\"));\n        setOpen(false);\n      })\n    }))\n  });\n});\nToast.displayName = TOAST_NAME;\nvar [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {}\n});\nvar ToastImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeToast,\n      type = \"foreground\",\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd\n    } = props,\n    toastProps = _objectWithoutProperties(props, _excluded4);\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [node, setNode] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node2 => setNode(node2));\n  const pointerStartRef = React.useRef(null);\n  const swipeDeltaRef = React.useRef(null);\n  const duration = durationProp || context.duration;\n  const closeTimerStartTimeRef = React.useRef(0);\n  const closeTimerRemainingTimeRef = React.useRef(duration);\n  const closeTimerRef = React.useRef(0);\n  const {\n    onToastAdd,\n    onToastRemove\n  } = context;\n  const handleClose = useCallbackRef(() => {\n    var _context$viewport2;\n    const isFocusInToast = node === null || node === void 0 ? void 0 : node.contains(document.activeElement);\n    if (isFocusInToast) (_context$viewport2 = context.viewport) === null || _context$viewport2 === void 0 || _context$viewport2.focus();\n    onClose();\n  });\n  const startTimer = React.useCallback(duration2 => {\n    if (!duration2 || duration2 === Infinity) return;\n    window.clearTimeout(closeTimerRef.current);\n    closeTimerStartTimeRef.current = (/* @__PURE__ */new Date()).getTime();\n    closeTimerRef.current = window.setTimeout(handleClose, duration2);\n  }, [handleClose]);\n  React.useEffect(() => {\n    const viewport = context.viewport;\n    if (viewport) {\n      const handleResume = () => {\n        startTimer(closeTimerRemainingTimeRef.current);\n        onResume === null || onResume === void 0 || onResume();\n      };\n      const handlePause = () => {\n        const elapsedTime = (/* @__PURE__ */new Date()).getTime() - closeTimerStartTimeRef.current;\n        closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n        window.clearTimeout(closeTimerRef.current);\n        onPause === null || onPause === void 0 || onPause();\n      };\n      viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n      viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n      return () => {\n        viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n      };\n    }\n  }, [context.viewport, duration, onPause, onResume, startTimer]);\n  React.useEffect(() => {\n    if (open && !context.isClosePausedRef.current) startTimer(duration);\n  }, [open, duration, context.isClosePausedRef, startTimer]);\n  React.useEffect(() => {\n    onToastAdd();\n    return () => onToastRemove();\n  }, [onToastAdd, onToastRemove]);\n  const announceTextContent = React.useMemo(() => {\n    return node ? getAnnounceTextContent(node) : null;\n  }, [node]);\n  if (!context.viewport) return null;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [announceTextContent && /* @__PURE__ */jsx(ToastAnnounce, {\n      __scopeToast,\n      role: \"status\",\n      \"aria-live\": type === \"foreground\" ? \"assertive\" : \"polite\",\n      children: announceTextContent\n    }), /* @__PURE__ */jsx(ToastInteractiveProvider, {\n      scope: __scopeToast,\n      onClose: handleClose,\n      children: ReactDOM.createPortal(/* @__PURE__ */jsx(Collection.ItemSlot, {\n        scope: __scopeToast,\n        children: /* @__PURE__ */jsx(DismissableLayer.Root, {\n          asChild: true,\n          onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {\n            if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n            context.isFocusedToastEscapeKeyDownRef.current = false;\n          }),\n          children: /* @__PURE__ */jsx(Primitive.li, _objectSpread(_objectSpread({\n            tabIndex: 0,\n            \"data-state\": open ? \"open\" : \"closed\",\n            \"data-swipe-direction\": context.swipeDirection\n          }, toastProps), {}, {\n            ref: composedRefs,\n            style: _objectSpread({\n              userSelect: \"none\",\n              touchAction: \"none\"\n            }, props.style),\n            onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n              if (event.key !== \"Escape\") return;\n              onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event.nativeEvent);\n              if (!event.nativeEvent.defaultPrevented) {\n                context.isFocusedToastEscapeKeyDownRef.current = true;\n                handleClose();\n              }\n            }),\n            onPointerDown: composeEventHandlers(props.onPointerDown, event => {\n              if (event.button !== 0) return;\n              pointerStartRef.current = {\n                x: event.clientX,\n                y: event.clientY\n              };\n            }),\n            onPointerMove: composeEventHandlers(props.onPointerMove, event => {\n              if (!pointerStartRef.current) return;\n              const x = event.clientX - pointerStartRef.current.x;\n              const y = event.clientY - pointerStartRef.current.y;\n              const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n              const isHorizontalSwipe = [\"left\", \"right\"].includes(context.swipeDirection);\n              const clamp = [\"left\", \"up\"].includes(context.swipeDirection) ? Math.min : Math.max;\n              const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n              const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n              const moveStartBuffer = event.pointerType === \"touch\" ? 10 : 2;\n              const delta = {\n                x: clampedX,\n                y: clampedY\n              };\n              const eventDetail = {\n                originalEvent: event,\n                delta\n              };\n              if (hasSwipeMoveStarted) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                  discrete: false\n                });\n              } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                  discrete: false\n                });\n                event.target.setPointerCapture(event.pointerId);\n              } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                pointerStartRef.current = null;\n              }\n            }),\n            onPointerUp: composeEventHandlers(props.onPointerUp, event => {\n              const delta = swipeDeltaRef.current;\n              const target = event.target;\n              if (target.hasPointerCapture(event.pointerId)) {\n                target.releasePointerCapture(event.pointerId);\n              }\n              swipeDeltaRef.current = null;\n              pointerStartRef.current = null;\n              if (delta) {\n                const toast = event.currentTarget;\n                const eventDetail = {\n                  originalEvent: event,\n                  delta\n                };\n                if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                    discrete: true\n                  });\n                } else {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail, {\n                    discrete: true\n                  });\n                }\n                toast.addEventListener(\"click\", event2 => event2.preventDefault(), {\n                  once: true\n                });\n              }\n            })\n          }))\n        })\n      }), context.viewport)\n    })]\n  });\n});\nvar ToastAnnounce = props => {\n  const {\n      __scopeToast,\n      children\n    } = props,\n    announceProps = _objectWithoutProperties(props, _excluded5);\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n  useNextFrame(() => setRenderAnnounceText(true));\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);\n    return () => window.clearTimeout(timer);\n  }, []);\n  return isAnnounced ? null : /* @__PURE__ */jsx(Portal, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(VisuallyHidden, _objectSpread(_objectSpread({}, announceProps), {}, {\n      children: renderAnnounceText && /* @__PURE__ */jsxs(Fragment, {\n        children: [context.label, \" \", children]\n      })\n    }))\n  });\n};\nvar TITLE_NAME = \"ToastTitle\";\nvar ToastTitle = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeToast\n    } = props,\n    titleProps = _objectWithoutProperties(props, _excluded6);\n  return /* @__PURE__ */jsx(Primitive.div, _objectSpread(_objectSpread({}, titleProps), {}, {\n    ref: forwardedRef\n  }));\n});\nToastTitle.displayName = TITLE_NAME;\nvar DESCRIPTION_NAME = \"ToastDescription\";\nvar ToastDescription = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeToast\n    } = props,\n    descriptionProps = _objectWithoutProperties(props, _excluded7);\n  return /* @__PURE__ */jsx(Primitive.div, _objectSpread(_objectSpread({}, descriptionProps), {}, {\n    ref: forwardedRef\n  }));\n});\nToastDescription.displayName = DESCRIPTION_NAME;\nvar ACTION_NAME = \"ToastAction\";\nvar ToastAction = React.forwardRef((props, forwardedRef) => {\n  const {\n      altText\n    } = props,\n    actionProps = _objectWithoutProperties(props, _excluded8);\n  if (!altText.trim()) {\n    console.error(\"Invalid prop `altText` supplied to `\".concat(ACTION_NAME, \"`. Expected non-empty `string`.\"));\n    return null;\n  }\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    altText,\n    asChild: true,\n    children: /* @__PURE__ */jsx(ToastClose, _objectSpread(_objectSpread({}, actionProps), {}, {\n      ref: forwardedRef\n    }))\n  });\n});\nToastAction.displayName = ACTION_NAME;\nvar CLOSE_NAME = \"ToastClose\";\nvar ToastClose = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeToast\n    } = props,\n    closeProps = _objectWithoutProperties(props, _excluded9);\n  const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(Primitive.button, _objectSpread(_objectSpread({\n      type: \"button\"\n    }, closeProps), {}, {\n      ref: forwardedRef,\n      onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)\n    }))\n  });\n});\nToastClose.displayName = CLOSE_NAME;\nvar ToastAnnounceExclude = React.forwardRef((props, forwardedRef) => {\n  const {\n      __scopeToast,\n      altText\n    } = props,\n    announceExcludeProps = _objectWithoutProperties(props, _excluded0);\n  return /* @__PURE__ */jsx(Primitive.div, _objectSpread(_objectSpread({\n    \"data-radix-toast-announce-exclude\": \"\",\n    \"data-radix-toast-announce-alt\": altText || void 0\n  }, announceExcludeProps), {}, {\n    ref: forwardedRef\n  }));\n});\nfunction getAnnounceTextContent(container) {\n  const textContent = [];\n  const childNodes = Array.from(container.childNodes);\n  childNodes.forEach(node => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === \"none\";\n      const isExcluded = node.dataset.radixToastAnnounceExclude === \"\";\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n  return textContent;\n}\nfunction handleAndDispatchCustomEvent(name, handler, detail, _ref2) {\n  let {\n    discrete\n  } = _ref2;\n  const currentTarget = detail.originalEvent.currentTarget;\n  const event = new CustomEvent(name, {\n    bubbles: true,\n    cancelable: true,\n    detail\n  });\n  if (handler) currentTarget.addEventListener(name, handler, {\n    once: true\n  });\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\nvar isDeltaInDirection = function (delta, direction) {\n  let threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === \"left\" || direction === \"right\") {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\nfunction useNextFrame() {\n  let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\nfunction isHTMLElement(node) {\n  return node.nodeType === node.ELEMENT_NODE;\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction focusFirst(candidates) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some(candidate => {\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\nvar Provider = ToastProvider;\nvar Viewport = ToastViewport;\nvar Root2 = Toast;\nvar Title = ToastTitle;\nvar Description = ToastDescription;\nvar Action = ToastAction;\nvar Close = ToastClose;\nexport { Action, Close, Description, Provider, Root2 as Root, Title, Toast, ToastAction, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport, Viewport, createToastScope };","map":{"version":3,"names":["React","ReactDOM","composeEventHandlers","useComposedRefs","createCollection","createContextScope","DismissableLayer","Portal","Presence","Primitive","dispatchDiscreteCustomEvent","useCallbackRef","useControllableState","useLayoutEffect","VisuallyHidden","Fragment","jsx","jsxs","PROVIDER_NAME","Collection","useCollection","createCollectionScope","createToastContext","createToastScope","ToastProviderProvider","useToastProviderContext","ToastProvider","props","__scopeToast","label","duration","swipeDirection","swipeThreshold","children","viewport","setViewport","useState","toastCount","setToastCount","isFocusedToastEscapeKeyDownRef","useRef","isClosePausedRef","trim","console","error","concat","Provider","scope","onViewportChange","onToastAdd","useCallback","prevCount","onToastRemove","displayName","VIEWPORT_NAME","VIEWPORT_DEFAULT_HOTKEY","VIEWPORT_PAUSE","VIEWPORT_RESUME","ToastViewport","forwardRef","forwardedRef","hotkey","viewportProps","_objectWithoutProperties","_excluded","context","getItems","wrapperRef","headFocusProxyRef","tailFocusProxyRef","ref","composedRefs","hotkeyLabel","join","replace","hasToasts","useEffect","handleKeyDown","event","_ref$current","isHotkeyPressed","length","every","key","code","current","focus","document","addEventListener","removeEventListener","wrapper","handlePause","pauseEvent","CustomEvent","dispatchEvent","handleResume","resumeEvent","handleFocusOutResume","isFocusMovingOutside","contains","relatedTarget","handlePointerLeaveResume","isFocusInside","activeElement","window","getSortedTabbableCandidates","_ref","tabbingDirection","toastItems","tabbableCandidates","map","toastItem","toastNode","toastTabbableCandidates","getTabbableCandidates","reverse","flat","isMetaKey","altKey","ctrlKey","metaKey","isTabKey","focusedElement","isTabbingBackwards","shiftKey","targetIsViewport","target","_headFocusProxyRef$cu","sortedCandidates","index","findIndex","candidate","focusFirst","slice","preventDefault","_headFocusProxyRef$cu2","_tailFocusProxyRef$cu","Branch","role","tabIndex","style","pointerEvents","FocusProxy","onFocusFromOutsideViewport","Slot","ol","_objectSpread","FOCUS_PROXY_NAME","proxyProps","_excluded2","position","onFocus","_context$viewport","prevFocusedElement","isFocusFromOutsideViewport","TOAST_NAME","TOAST_SWIPE_START","TOAST_SWIPE_MOVE","TOAST_SWIPE_CANCEL","TOAST_SWIPE_END","Toast","forceMount","open","openProp","defaultOpen","onOpenChange","toastProps","_excluded3","setOpen","prop","defaultProp","onChange","caller","present","ToastImpl","onClose","onPause","onResume","onSwipeStart","currentTarget","setAttribute","onSwipeMove","x","y","detail","delta","setProperty","onSwipeCancel","removeProperty","onSwipeEnd","ToastInteractiveProvider","useToastInteractiveContext","type","durationProp","onEscapeKeyDown","_excluded4","node","setNode","node2","pointerStartRef","swipeDeltaRef","closeTimerStartTimeRef","closeTimerRemainingTimeRef","closeTimerRef","handleClose","_context$viewport2","isFocusInToast","startTimer","duration2","Infinity","clearTimeout","Date","getTime","setTimeout","elapsedTime","announceTextContent","useMemo","getAnnounceTextContent","ToastAnnounce","createPortal","ItemSlot","Root","asChild","li","userSelect","touchAction","onKeyDown","nativeEvent","defaultPrevented","onPointerDown","button","clientX","clientY","onPointerMove","hasSwipeMoveStarted","Boolean","isHorizontalSwipe","includes","clamp","Math","min","max","clampedX","clampedY","moveStartBuffer","pointerType","eventDetail","originalEvent","handleAndDispatchCustomEvent","discrete","isDeltaInDirection","setPointerCapture","pointerId","abs","onPointerUp","hasPointerCapture","releasePointerCapture","toast","event2","once","announceProps","_excluded5","renderAnnounceText","setRenderAnnounceText","isAnnounced","setIsAnnounced","useNextFrame","timer","TITLE_NAME","ToastTitle","titleProps","_excluded6","div","DESCRIPTION_NAME","ToastDescription","descriptionProps","_excluded7","ACTION_NAME","ToastAction","altText","actionProps","_excluded8","ToastAnnounceExclude","ToastClose","CLOSE_NAME","closeProps","_excluded9","interactiveContext","onClick","announceExcludeProps","_excluded0","container","textContent","childNodes","Array","from","forEach","nodeType","TEXT_NODE","push","isHTMLElement","isHidden","ariaHidden","hidden","display","isExcluded","dataset","radixToastAnnounceExclude","radixToastAnnounceAlt","name","handler","_ref2","bubbles","cancelable","direction","threshold","arguments","undefined","deltaX","deltaY","isDeltaX","callback","fn","raf1","raf2","requestAnimationFrame","cancelAnimationFrame","ELEMENT_NODE","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","disabled","FILTER_SKIP","FILTER_ACCEPT","nextNode","currentNode","candidates","previouslyFocusedElement","some","Viewport","Root2","Title","Description","Action","Close"],"sources":["/home/nazim/Documents/Portfolio/PortFolio/frontend/node_modules/@radix-ui/react-toast/src/toast.tsx"],"sourcesContent":["import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { createContextScope } from '@radix-ui/react-context';\nimport * as DismissableLayer from '@radix-ui/react-dismissable-layer';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToastProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'ToastProvider';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<ToastElement>('Toast');\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right';\ntype ToastProviderContextValue = {\n  label: string;\n  duration: number;\n  swipeDirection: SwipeDirection;\n  swipeThreshold: number;\n  toastCount: number;\n  viewport: ToastViewportElement | null;\n  onViewportChange(viewport: ToastViewportElement): void;\n  onToastAdd(): void;\n  onToastRemove(): void;\n  isFocusedToastEscapeKeyDownRef: React.MutableRefObject<boolean>;\n  isClosePausedRef: React.MutableRefObject<boolean>;\n};\n\ntype ScopedProps<P> = P & { __scopeToast?: Scope };\nconst [createToastContext, createToastScope] = createContextScope('Toast', [createCollectionScope]);\nconst [ToastProviderProvider, useToastProviderContext] =\n  createToastContext<ToastProviderContextValue>(PROVIDER_NAME);\n\ninterface ToastProviderProps {\n  children?: React.ReactNode;\n  /**\n   * An author-localized label for each toast. Used to help screen reader users\n   * associate the interruption with a toast.\n   * @defaultValue 'Notification'\n   */\n  label?: string;\n  /**\n   * Time in milliseconds that each toast should remain visible for.\n   * @defaultValue 5000\n   */\n  duration?: number;\n  /**\n   * Direction of pointer swipe that should close the toast.\n   * @defaultValue 'right'\n   */\n  swipeDirection?: SwipeDirection;\n  /**\n   * Distance in pixels that the swipe must pass before a close is triggered.\n   * @defaultValue 50\n   */\n  swipeThreshold?: number;\n}\n\nconst ToastProvider: React.FC<ToastProviderProps> = (props: ScopedProps<ToastProviderProps>) => {\n  const {\n    __scopeToast,\n    label = 'Notification',\n    duration = 5000,\n    swipeDirection = 'right',\n    swipeThreshold = 50,\n    children,\n  } = props;\n  const [viewport, setViewport] = React.useState<ToastViewportElement | null>(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n\n  if (!label.trim()) {\n    console.error(\n      `Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`\n    );\n  }\n\n  return (\n    <Collection.Provider scope={__scopeToast}>\n      <ToastProviderProvider\n        scope={__scopeToast}\n        label={label}\n        duration={duration}\n        swipeDirection={swipeDirection}\n        swipeThreshold={swipeThreshold}\n        toastCount={toastCount}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        onToastAdd={React.useCallback(() => setToastCount((prevCount) => prevCount + 1), [])}\n        onToastRemove={React.useCallback(() => setToastCount((prevCount) => prevCount - 1), [])}\n        isFocusedToastEscapeKeyDownRef={isFocusedToastEscapeKeyDownRef}\n        isClosePausedRef={isClosePausedRef}\n      >\n        {children}\n      </ToastProviderProvider>\n    </Collection.Provider>\n  );\n};\n\nToastProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ToastViewport';\nconst VIEWPORT_DEFAULT_HOTKEY = ['F8'];\nconst VIEWPORT_PAUSE = 'toast.viewportPause';\nconst VIEWPORT_RESUME = 'toast.viewportResume';\n\ntype ToastViewportElement = React.ComponentRef<typeof Primitive.ol>;\ntype PrimitiveOrderedListProps = React.ComponentPropsWithoutRef<typeof Primitive.ol>;\ninterface ToastViewportProps extends PrimitiveOrderedListProps {\n  /**\n   * The keys to use as the keyboard shortcut that will move focus to the toast viewport.\n   * @defaultValue ['F8']\n   */\n  hotkey?: string[];\n  /**\n   * An author-localized label for the toast viewport to provide context for screen reader users\n   * when navigating page landmarks. The available `{hotkey}` placeholder will be replaced for you.\n   * @defaultValue 'Notifications ({hotkey})'\n   */\n  label?: string;\n}\n\nconst ToastViewport = React.forwardRef<ToastViewportElement, ToastViewportProps>(\n  (props: ScopedProps<ToastViewportProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = 'Notifications ({hotkey})',\n      ...viewportProps\n    } = props;\n    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n    const getItems = useCollection(__scopeToast);\n    const wrapperRef = React.useRef<HTMLDivElement>(null);\n    const headFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const tailFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const ref = React.useRef<ToastViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');\n    const hasToasts = context.toastCount > 0;\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        // we use `event.code` as it is consistent regardless of meta keys that were pressed.\n        // for example, `event.key` for `Control+Alt+t` is `†` and `t !== †`\n        const isHotkeyPressed =\n          hotkey.length !== 0 && hotkey.every((key) => (event as any)[key] || event.code === key);\n        if (isHotkeyPressed) ref.current?.focus();\n      };\n      document.addEventListener('keydown', handleKeyDown);\n      return () => document.removeEventListener('keydown', handleKeyDown);\n    }, [hotkey]);\n\n    React.useEffect(() => {\n      const wrapper = wrapperRef.current;\n      const viewport = ref.current;\n      if (hasToasts && wrapper && viewport) {\n        const handlePause = () => {\n          if (!context.isClosePausedRef.current) {\n            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n            viewport.dispatchEvent(pauseEvent);\n            context.isClosePausedRef.current = true;\n          }\n        };\n\n        const handleResume = () => {\n          if (context.isClosePausedRef.current) {\n            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n            viewport.dispatchEvent(resumeEvent);\n            context.isClosePausedRef.current = false;\n          }\n        };\n\n        const handleFocusOutResume = (event: FocusEvent) => {\n          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget as HTMLElement);\n          if (isFocusMovingOutside) handleResume();\n        };\n\n        const handlePointerLeaveResume = () => {\n          const isFocusInside = wrapper.contains(document.activeElement);\n          if (!isFocusInside) handleResume();\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        wrapper.addEventListener('focusin', handlePause);\n        wrapper.addEventListener('focusout', handleFocusOutResume);\n        wrapper.addEventListener('pointermove', handlePause);\n        wrapper.addEventListener('pointerleave', handlePointerLeaveResume);\n        window.addEventListener('blur', handlePause);\n        window.addEventListener('focus', handleResume);\n        return () => {\n          wrapper.removeEventListener('focusin', handlePause);\n          wrapper.removeEventListener('focusout', handleFocusOutResume);\n          wrapper.removeEventListener('pointermove', handlePause);\n          wrapper.removeEventListener('pointerleave', handlePointerLeaveResume);\n          window.removeEventListener('blur', handlePause);\n          window.removeEventListener('focus', handleResume);\n        };\n      }\n    }, [hasToasts, context.isClosePausedRef]);\n\n    const getSortedTabbableCandidates = React.useCallback(\n      ({ tabbingDirection }: { tabbingDirection: 'forwards' | 'backwards' }) => {\n        const toastItems = getItems();\n        const tabbableCandidates = toastItems.map((toastItem) => {\n          const toastNode = toastItem.ref.current!;\n          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n          return tabbingDirection === 'forwards'\n            ? toastTabbableCandidates\n            : toastTabbableCandidates.reverse();\n        });\n        return (\n          tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates\n        ).flat();\n      },\n      [getItems]\n    );\n\n    React.useEffect(() => {\n      const viewport = ref.current;\n      // We programmatically manage tabbing as we are unable to influence\n      // the source order with portals, this allows us to reverse the\n      // tab order so that it runs from most recent toast to least\n      if (viewport) {\n        const handleKeyDown = (event: KeyboardEvent) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n\n          if (isTabKey) {\n            const focusedElement = document.activeElement;\n            const isTabbingBackwards = event.shiftKey;\n            const targetIsViewport = event.target === viewport;\n\n            // If we're back tabbing after jumping to the viewport then we simply\n            // proxy focus out to the preceding document\n            if (targetIsViewport && isTabbingBackwards) {\n              headFocusProxyRef.current?.focus();\n              return;\n            }\n\n            const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards';\n            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });\n            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);\n            if (focusFirst(sortedCandidates.slice(index + 1))) {\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges so we\n              // proxy to the corresponding exit point and let the browser handle\n              // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document\n              isTabbingBackwards\n                ? headFocusProxyRef.current?.focus()\n                : tailFocusProxyRef.current?.focus();\n            }\n          }\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        viewport.addEventListener('keydown', handleKeyDown);\n        return () => viewport.removeEventListener('keydown', handleKeyDown);\n      }\n    }, [getItems, getSortedTabbableCandidates]);\n\n    return (\n      <DismissableLayer.Branch\n        ref={wrapperRef}\n        role=\"region\"\n        aria-label={label.replace('{hotkey}', hotkeyLabel)}\n        // Ensure virtual cursor from landmarks menus triggers focus/blur for pause/resume\n        tabIndex={-1}\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        style={{ pointerEvents: hasToasts ? undefined : 'none' }}\n      >\n        {hasToasts && (\n          <FocusProxy\n            ref={headFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'forwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n        {/**\n         * tabindex on the the list so that it can be focused when items are removed. we focus\n         * the list instead of the viewport so it announces number of items remaining.\n         */}\n        <Collection.Slot scope={__scopeToast}>\n          <Primitive.ol tabIndex={-1} {...viewportProps} ref={composedRefs} />\n        </Collection.Slot>\n        {hasToasts && (\n          <FocusProxy\n            ref={tailFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'backwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n      </DismissableLayer.Branch>\n    );\n  }\n);\n\nToastViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_PROXY_NAME = 'ToastFocusProxy';\n\ntype FocusProxyElement = React.ComponentRef<typeof VisuallyHidden>;\ntype VisuallyHiddenProps = React.ComponentPropsWithoutRef<typeof VisuallyHidden>;\ninterface FocusProxyProps extends VisuallyHiddenProps {\n  onFocusFromOutsideViewport(): void;\n}\n\nconst FocusProxy = React.forwardRef<FocusProxyElement, ScopedProps<FocusProxyProps>>(\n  (props, forwardedRef) => {\n    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;\n    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n\n    return (\n      <VisuallyHidden\n        tabIndex={0}\n        {...proxyProps}\n        ref={forwardedRef}\n        // Avoid page scrolling when focus is on the focus proxy\n        style={{ position: 'fixed' }}\n        onFocus={(event) => {\n          const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n        }}\n      />\n    );\n  }\n);\n\nFocusProxy.displayName = FOCUS_PROXY_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Toast\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOAST_NAME = 'Toast';\nconst TOAST_SWIPE_START = 'toast.swipeStart';\nconst TOAST_SWIPE_MOVE = 'toast.swipeMove';\nconst TOAST_SWIPE_CANCEL = 'toast.swipeCancel';\nconst TOAST_SWIPE_END = 'toast.swipeEnd';\n\ntype ToastElement = ToastImplElement;\ninterface ToastProps extends Omit<ToastImplProps, keyof ToastImplPrivateProps> {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst Toast = React.forwardRef<ToastElement, ToastProps>(\n  (props: ScopedProps<ToastProps>, forwardedRef) => {\n    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;\n    const [open, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen ?? true,\n      onChange: onOpenChange,\n      caller: TOAST_NAME,\n    });\n    return (\n      <Presence present={forceMount || open}>\n        <ToastImpl\n          open={open}\n          {...toastProps}\n          ref={forwardedRef}\n          onClose={() => setOpen(false)}\n          onPause={useCallbackRef(props.onPause)}\n          onResume={useCallbackRef(props.onResume)}\n          onSwipeStart={composeEventHandlers(props.onSwipeStart, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'start');\n          })}\n          onSwipeMove={composeEventHandlers(props.onSwipeMove, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'move');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y}px`);\n          })}\n          onSwipeCancel={composeEventHandlers(props.onSwipeCancel, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'cancel');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y');\n          })}\n          onSwipeEnd={composeEventHandlers(props.onSwipeEnd, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'end');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y}px`);\n            setOpen(false);\n          })}\n        />\n      </Presence>\n    );\n  }\n);\n\nToast.displayName = TOAST_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype SwipeEvent = { currentTarget: EventTarget & ToastElement } & Omit<\n  CustomEvent<{ originalEvent: React.PointerEvent; delta: { x: number; y: number } }>,\n  'currentTarget'\n>;\n\nconst [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {},\n});\n\ntype ToastImplElement = React.ComponentRef<typeof Primitive.li>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer.Root>;\ntype ToastImplPrivateProps = { open: boolean; onClose(): void };\ntype PrimitiveListItemProps = React.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface ToastImplProps extends ToastImplPrivateProps, PrimitiveListItemProps {\n  type?: 'foreground' | 'background';\n  /**\n   * Time in milliseconds that toast should remain visible for. Overrides value\n   * given to `ToastProvider`.\n   */\n  duration?: number;\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPause?(): void;\n  onResume?(): void;\n  onSwipeStart?(event: SwipeEvent): void;\n  onSwipeMove?(event: SwipeEvent): void;\n  onSwipeCancel?(event: SwipeEvent): void;\n  onSwipeEnd?(event: SwipeEvent): void;\n}\n\nconst ToastImpl = React.forwardRef<ToastImplElement, ToastImplProps>(\n  (props: ScopedProps<ToastImplProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      type = 'foreground',\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd,\n      ...toastProps\n    } = props;\n    const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n    const [node, setNode] = React.useState<ToastImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const pointerStartRef = React.useRef<{ x: number; y: number } | null>(null);\n    const swipeDeltaRef = React.useRef<{ x: number; y: number } | null>(null);\n    const duration = durationProp || context.duration;\n    const closeTimerStartTimeRef = React.useRef(0);\n    const closeTimerRemainingTimeRef = React.useRef(duration);\n    const closeTimerRef = React.useRef(0);\n    const { onToastAdd, onToastRemove } = context;\n    const handleClose = useCallbackRef(() => {\n      // focus viewport if focus is within toast to read the remaining toast\n      // count to SR users and ensure focus isn't lost\n      const isFocusInToast = node?.contains(document.activeElement);\n      if (isFocusInToast) context.viewport?.focus();\n      onClose();\n    });\n\n    const startTimer = React.useCallback(\n      (duration: number) => {\n        if (!duration || duration === Infinity) return;\n        window.clearTimeout(closeTimerRef.current);\n        closeTimerStartTimeRef.current = new Date().getTime();\n        closeTimerRef.current = window.setTimeout(handleClose, duration);\n      },\n      [handleClose]\n    );\n\n    React.useEffect(() => {\n      const viewport = context.viewport;\n      if (viewport) {\n        const handleResume = () => {\n          startTimer(closeTimerRemainingTimeRef.current);\n          onResume?.();\n        };\n        const handlePause = () => {\n          const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;\n          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n          window.clearTimeout(closeTimerRef.current);\n          onPause?.();\n        };\n        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n        return () => {\n          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n        };\n      }\n    }, [context.viewport, duration, onPause, onResume, startTimer]);\n\n    // start timer when toast opens or duration changes.\n    // we include `open` in deps because closed !== unmounted when animating\n    // so it could reopen before being completely unmounted\n    React.useEffect(() => {\n      if (open && !context.isClosePausedRef.current) startTimer(duration);\n    }, [open, duration, context.isClosePausedRef, startTimer]);\n\n    React.useEffect(() => {\n      onToastAdd();\n      return () => onToastRemove();\n    }, [onToastAdd, onToastRemove]);\n\n    const announceTextContent = React.useMemo(() => {\n      return node ? getAnnounceTextContent(node) : null;\n    }, [node]);\n\n    if (!context.viewport) return null;\n\n    return (\n      <>\n        {announceTextContent && (\n          <ToastAnnounce\n            __scopeToast={__scopeToast}\n            // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.\n            role=\"status\"\n            aria-live={type === 'foreground' ? 'assertive' : 'polite'}\n          >\n            {announceTextContent}\n          </ToastAnnounce>\n        )}\n\n        <ToastInteractiveProvider scope={__scopeToast} onClose={handleClose}>\n          {ReactDOM.createPortal(\n            <Collection.ItemSlot scope={__scopeToast}>\n              <DismissableLayer.Root\n                asChild\n                onEscapeKeyDown={composeEventHandlers(onEscapeKeyDown, () => {\n                  if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n                  context.isFocusedToastEscapeKeyDownRef.current = false;\n                })}\n              >\n                <Primitive.li\n                  tabIndex={0}\n                  data-state={open ? 'open' : 'closed'}\n                  data-swipe-direction={context.swipeDirection}\n                  {...toastProps}\n                  ref={composedRefs}\n                  style={{ userSelect: 'none', touchAction: 'none', ...props.style }}\n                  onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                    if (event.key !== 'Escape') return;\n                    onEscapeKeyDown?.(event.nativeEvent);\n                    if (!event.nativeEvent.defaultPrevented) {\n                      context.isFocusedToastEscapeKeyDownRef.current = true;\n                      handleClose();\n                    }\n                  })}\n                  onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                    if (event.button !== 0) return;\n                    pointerStartRef.current = { x: event.clientX, y: event.clientY };\n                  })}\n                  onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n                    if (!pointerStartRef.current) return;\n                    const x = event.clientX - pointerStartRef.current.x;\n                    const y = event.clientY - pointerStartRef.current.y;\n                    const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n                    const isHorizontalSwipe = ['left', 'right'].includes(context.swipeDirection);\n                    const clamp = ['left', 'up'].includes(context.swipeDirection)\n                      ? Math.min\n                      : Math.max;\n                    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n                    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n                    const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;\n                    const delta = { x: clampedX, y: clampedY };\n                    const eventDetail = { originalEvent: event, delta };\n                    if (hasSwipeMoveStarted) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                        discrete: false,\n                      });\n                    } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                        discrete: false,\n                      });\n                      (event.target as HTMLElement).setPointerCapture(event.pointerId);\n                    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                      // User is swiping in wrong direction so we disable swipe gesture\n                      // for the current pointer down interaction\n                      pointerStartRef.current = null;\n                    }\n                  })}\n                  onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n                    const delta = swipeDeltaRef.current;\n                    const target = event.target as HTMLElement;\n                    if (target.hasPointerCapture(event.pointerId)) {\n                      target.releasePointerCapture(event.pointerId);\n                    }\n                    swipeDeltaRef.current = null;\n                    pointerStartRef.current = null;\n                    if (delta) {\n                      const toast = event.currentTarget;\n                      const eventDetail = { originalEvent: event, delta };\n                      if (\n                        isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)\n                      ) {\n                        handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                          discrete: true,\n                        });\n                      } else {\n                        handleAndDispatchCustomEvent(\n                          TOAST_SWIPE_CANCEL,\n                          onSwipeCancel,\n                          eventDetail,\n                          {\n                            discrete: true,\n                          }\n                        );\n                      }\n                      // Prevent click event from triggering on items within the toast when\n                      // pointer up is part of a swipe gesture\n                      toast.addEventListener('click', (event) => event.preventDefault(), {\n                        once: true,\n                      });\n                    }\n                  })}\n                />\n              </DismissableLayer.Root>\n            </Collection.ItemSlot>,\n            context.viewport\n          )}\n        </ToastInteractiveProvider>\n      </>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface ToastAnnounceProps\n  extends Omit<React.ComponentPropsWithoutRef<'div'>, 'children'>,\n    ScopedProps<{ children: string[] }> {}\n\nconst ToastAnnounce: React.FC<ToastAnnounceProps> = (props: ScopedProps<ToastAnnounceProps>) => {\n  const { __scopeToast, children, ...announceProps } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n\n  // render text content in the next frame to ensure toast is announced in NVDA\n  useNextFrame(() => setRenderAnnounceText(true));\n\n  // cleanup after announcing\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1000);\n    return () => window.clearTimeout(timer);\n  }, []);\n\n  return isAnnounced ? null : (\n    <Portal asChild>\n      <VisuallyHidden {...announceProps}>\n        {renderAnnounceText && (\n          <>\n            {context.label} {children}\n          </>\n        )}\n      </VisuallyHidden>\n    </Portal>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ToastTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'ToastTitle';\n\ntype ToastTitleElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToastTitleProps extends PrimitiveDivProps {}\n\nconst ToastTitle = React.forwardRef<ToastTitleElement, ToastTitleProps>(\n  (props: ScopedProps<ToastTitleProps>, forwardedRef) => {\n    const { __scopeToast, ...titleProps } = props;\n    return <Primitive.div {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nToastTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'ToastDescription';\n\ntype ToastDescriptionElement = React.ComponentRef<typeof Primitive.div>;\ninterface ToastDescriptionProps extends PrimitiveDivProps {}\n\nconst ToastDescription = React.forwardRef<ToastDescriptionElement, ToastDescriptionProps>(\n  (props: ScopedProps<ToastDescriptionProps>, forwardedRef) => {\n    const { __scopeToast, ...descriptionProps } = props;\n    return <Primitive.div {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nToastDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastAction\n * -----------------------------------------------------------------------------------------------*/\n\nconst ACTION_NAME = 'ToastAction';\n\ntype ToastActionElement = ToastCloseElement;\ninterface ToastActionProps extends ToastCloseProps {\n  /**\n   * A short description for an alternate way to carry out the action. For screen reader users\n   * who will not be able to navigate to the button easily/quickly.\n   * @example <ToastAction altText=\"Goto account settings to upgrade\">Upgrade</ToastAction>\n   * @example <ToastAction altText=\"Undo (Alt+U)\">Undo</ToastAction>\n   */\n  altText: string;\n}\n\nconst ToastAction = React.forwardRef<ToastActionElement, ToastActionProps>(\n  (props: ScopedProps<ToastActionProps>, forwardedRef) => {\n    const { altText, ...actionProps } = props;\n\n    if (!altText.trim()) {\n      console.error(\n        `Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`\n      );\n      return null;\n    }\n\n    return (\n      <ToastAnnounceExclude altText={altText} asChild>\n        <ToastClose {...actionProps} ref={forwardedRef} />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastAction.displayName = ACTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'ToastClose';\n\ntype ToastCloseElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToastCloseProps extends PrimitiveButtonProps {}\n\nconst ToastClose = React.forwardRef<ToastCloseElement, ToastCloseProps>(\n  (props: ScopedProps<ToastCloseProps>, forwardedRef) => {\n    const { __scopeToast, ...closeProps } = props;\n    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n\n    return (\n      <ToastAnnounceExclude asChild>\n        <Primitive.button\n          type=\"button\"\n          {...closeProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(props.onClick, interactiveContext.onClose)}\n        />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastClose.displayName = CLOSE_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype ToastAnnounceExcludeElement = React.ComponentRef<typeof Primitive.div>;\ninterface ToastAnnounceExcludeProps extends PrimitiveDivProps {\n  altText?: string;\n}\n\nconst ToastAnnounceExclude = React.forwardRef<\n  ToastAnnounceExcludeElement,\n  ToastAnnounceExcludeProps\n>((props: ScopedProps<ToastAnnounceExcludeProps>, forwardedRef) => {\n  const { __scopeToast, altText, ...announceExcludeProps } = props;\n\n  return (\n    <Primitive.div\n      data-radix-toast-announce-exclude=\"\"\n      data-radix-toast-announce-alt={altText || undefined}\n      {...announceExcludeProps}\n      ref={forwardedRef}\n    />\n  );\n});\n\nfunction getAnnounceTextContent(container: HTMLElement) {\n  const textContent: string[] = [];\n  const childNodes = Array.from(container.childNodes);\n\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none';\n      const isExcluded = node.dataset.radixToastAnnounceExclude === '';\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n\n  // We return a collection of text rather than a single concatenated string.\n  // This allows SR VO to naturally pause break between nodes while announcing.\n  return textContent;\n}\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  ReactEvent extends React.SyntheticEvent,\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: ReactEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const currentTarget = detail.originalEvent.currentTarget as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });\n  if (handler) currentTarget.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\n\nconst isDeltaInDirection = (\n  delta: { x: number; y: number },\n  direction: SwipeDirection,\n  threshold = 0\n) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === 'left' || direction === 'right') {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\n\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => (raf2 = window.requestAnimationFrame(fn)));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\n\nfunction isHTMLElement(node: any): node is HTMLElement {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nconst Provider = ToastProvider;\nconst Viewport = ToastViewport;\nconst Root = Toast;\nconst Title = ToastTitle;\nconst Description = ToastDescription;\nconst Action = ToastAction;\nconst Close = ToastClose;\n\nexport {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n};\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}